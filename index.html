<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”æ³•ç¼–ç¨‹å†’é™©åŸå‹</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-bg: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text-main: #ecf0f1;
            --text-dim: #95a5a6;
            --gauge-bg: #333;
            --gauge-fill: #3498db;
            --cast-bar: #f1c40f;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #app {
            width: 100%;
            max-width: 800px;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* --- é¡¶éƒ¨çŠ¶æ€æ  --- */
        header {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent);
        }

        .stat-box { font-size: 14px; }
        .hp-bar-container, .mp-bar-container {
            width: 150px;
            height: 10px;
            background: var(--gauge-bg);
            margin-top: 5px;
            border-radius: 5px;
            overflow: hidden;
        }
        .hp-fill { height: 100%; background: #e74c3c; width: 100%; transition: width 0.3s; }
        .mp-fill { height: 100%; background: #3498db; width: 100%; transition: width 0.3s; }

        /* --- ä¸»åœºæ™¯åŒºåŸŸ --- */
        #scene-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, #2a2a4a 0%, #1a1a2e 100%);
            overflow: hidden;
        }

        .battle-field {
            display: flex;
            justify-content: space-between;
            width: 80%;
            align-items: flex-end;
            margin-bottom: 20px;
        }

        .unit {
            text-align: center;
            position: relative;
            width: 100px;
        }

        .unit-avatar {
            width: 80px;
            height: 80px;
            background: #444;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            border: 3px solid #666;
            transition: transform 0.2s, border-color 0.2s;
        }

        .unit.ready .unit-avatar {
            border-color: var(--highlight);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--highlight);
            animation: pulse 1s infinite;
        }

        .unit.casting .unit-avatar {
            border-color: var(--cast-bar);
        }

        .unit.stunned .unit-avatar {
            filter: grayscale(100%);
            opacity: 0.6;
        }

        /* ATB è¡ŒåŠ¨æ¡ */
        .atb-container {
            width: 100%;
            height: 6px;
            background: var(--gauge-bg);
            border-radius: 3px;
            margin-top: 5px;
            position: relative;
        }
        .atb-fill {
            height: 100%;
            background: var(--gauge-fill);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* åŸå”±æ¡ (è¦†ç›–åœ¨ ATB ä¸Šæˆ–ç‹¬ç«‹) */
        .cast-container {
            width: 100%;
            height: 4px;
            background: transparent;
            margin-top: 2px;
            display: none; /* é»˜è®¤éšè— */
        }
        .unit.casting .cast-container { display: block; }
        .cast-fill {
            height: 100%;
            background: var(--cast-bar);
            width: 0%;
        }

        /* æˆ˜æ–—æ—¥å¿— */
        #combat-log {
            width: 90%;
            height: 100px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #444;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            font-family: monospace;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .log-entry { margin-bottom: 4px; }
        .log-player { color: #81ecec; }
        .log-enemy { color: #ff7675; }
        .log-system { color: #ffeaa7; }
        .log-error { color: #fd79a8; font-weight: bold; }

        /* --- åº•éƒ¨æ§åˆ¶åŒº --- */
        #control-panel {
            height: 220px;
            background: #0f1526;
            border-top: 2px solid var(--accent);
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 14px;
            color: var(--text-dim);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* è¥åœ°ç¼–è¾‘å™¨æ ·å¼ */
        .spell-slots {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            justify-content: center;
        }
        .slot {
            width: 140px;
            height: 60px;
            background: #222;
            border: 2px dashed #555;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .slot.filled {
            border-style: solid;
            border-color: var(--accent);
            background: #1a253a;
        }
        .slot-info {
            font-size: 12px;
            text-align: center;
            width: 100%;
            padding: 0 5px;
        }
        .slot-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            background: red;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            display: none;
        }
        .slot:hover .slot-remove { display: flex; }

        .rune-library {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
        }
        .rune-item {
            min-width: 80px;
            height: 80px;
            background: #2c3e50;
            border: 1px solid #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: transform 0.1s;
        }
        .rune-item:hover { transform: translateY(-3px); background: #34495e; }
        .rune-icon { font-size: 24px; margin-bottom: 5px; }
        .rune-type { font-size: 10px; color: #aaa; }

        /* æˆ˜æ–—æ“ä½œåŒº */
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            height: 100%;
        }
        .spell-btn {
            flex: 1;
            max-width: 150px;
            background: linear-gradient(145deg, #2c3e50, #1a253a);
            border: 1px solid #444;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #34495e, #2c3e50);
            border-color: var(--gauge-fill);
        }
        .spell-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        .spell-btn .cost {
            font-size: 10px;
            color: #3498db;
            margin-top: 4px;
        }
        .spell-btn .time {
            font-size: 10px;
            color: #f1c40f;
        }

        /* å…¨å±€æŒ‰é’® */
        .btn-primary {
            background: var(--highlight);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-primary:hover { opacity: 0.9; }

        /* åŠ¨ç”» */
        @keyframes pulse {
            0% { transform: scale(1.1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1.1); }
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        .shake { animation: shake 0.3s; }

        /* åœºæ™¯åˆ‡æ¢é®ç½© */
        #overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
        }
        #overlay.active { display: flex; }
        .overlay-content {
            background: var(--panel-bg);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--accent);
        }
    </style>
</head>
<body>

<div id="app">
    <header>
        <div class="stat-box">
            <div>HP <span id="player-hp-text">100/100</span></div>
            <div class="hp-bar-container"><div id="player-hp-bar" class="hp-fill"></div></div>
        </div>
        <div style="font-weight:bold; color:var(--highlight);" id="scene-title">é‡å¤–é­é‡</div>
        <div class="stat-box" style="text-align:right;">
            <div>MP <span id="player-mp-text">50/50</span></div>
            <div class="mp-bar-container"><div id="player-mp-bar" class="mp-fill"></div></div>
        </div>
    </header>

    <div id="scene-area">
        <!-- æˆ˜æ–—åœºæ™¯ -->
        <div class="battle-field" id="battle-field" style="display:none;">
            <!-- ç©å®¶ -->
            <div class="unit" id="unit-player">
                <div class="unit-avatar">ğŸ§™â€â™‚ï¸</div>
                <div class="atb-container"><div class="atb-fill" id="player-atb"></div></div>
                <div class="cast-container"><div class="cast-fill" id="player-cast"></div></div>
                <div style="font-size:12px; margin-top:5px;">æ³•å¸ˆ</div>
            </div>
            <!-- æ•Œäºº -->
            <div class="unit" id="unit-enemy">
                <div class="unit-avatar">ğŸº</div>
                <div class="atb-container"><div class="atb-fill" id="enemy-atb"></div></div>
                <div style="font-size:12px; margin-top:5px;" id="enemy-name">æ¶ç‹¼</div>
                <div style="font-size:10px; color:#aaa;" id="enemy-hp-text">HP: 80</div>
            </div>
        </div>

        <!-- è¥åœ°åœºæ™¯ (ç®€å•ç¤ºæ„) -->
        <div id="camp-scene" style="display:none; text-align:center;">
            <h2>ğŸ•ï¸ å®‰å…¨è¥åœ°</h2>
            <p>åœ¨æ­¤è°ƒæ•´ä½ çš„æ³•æœ¯ç»„åˆ</p>
            <div style="font-size:40px; margin:20px;">â›º</div>
        </div>

        <div id="combat-log"></div>
    </div>

    <div id="control-panel">
        <!-- è¥åœ°ç¼–è¾‘ç•Œé¢ -->
        <div id="camp-editor" style="display:none; height:100%;">
            <div class="panel-title">æ³•æœ¯å¡æ§½ (ç‚¹å‡»ç¬¦æ–‡æ·»åŠ ï¼Œç‚¹å‡»æ§½ä½ç§»é™¤)</div>
            <div class="spell-slots" id="spell-slots-container">
                <!-- ç”± JS ç”Ÿæˆ -->
            </div>
            
            <div class="panel-title">ç¬¦æ–‡åº“</div>
            <div class="rune-library" id="rune-library">
                <!-- ç”± JS ç”Ÿæˆ -->
            </div>
            
            <div style="margin-top:20px; text-align:center;">
                <button class="btn-primary" onclick="game.leaveCamp()">ç¦»å¼€è¥åœ° (ä¿å­˜å¹¶å‡ºå‘)</button>
            </div>
        </div>

        <!-- æˆ˜æ–—æ“ä½œç•Œé¢ -->
        <div id="battle-controls" style="height:100%;">
            <div class="panel-title">å¯ç”¨æ³•æœ¯ (è¡ŒåŠ¨æ¡æ»¡æ—¶ç‚¹å‡»)</div>
            <div class="action-buttons" id="action-buttons">
                <!-- ç”± JS ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- è¦†ç›–å±‚ (èƒœåˆ©/å¤±è´¥/èœå•) -->
    <div id="overlay">
        <div class="overlay-content">
            <h2 id="overlay-title">æˆ˜æ–—èƒœåˆ©!</h2>
            <p id="overlay-msg">è·å¾—äº†ç»éªŒå€¼ã€‚</p>
            <button class="btn-primary" onclick="game.handleOverlayAction()">ç»§ç»­</button>
        </div>
    </div>
</div>

<script>
/**
 * æ•°æ®å®šä¹‰
 */
const RUNES = {
    // æ ¸å¿ƒç¬¦
    'firebolt': { id: 'firebolt', name: 'ç«çƒæœ¯', type: 'CORE', icon: 'ğŸ”¥', baseDmg: 25, cost: 10, time: 1.5, desc: 'åŸºç¡€ç«ç„°ä¼¤å®³' },
    'ice shard': { id: 'ice shard', name: 'å†°é”¥æœ¯', type: 'CORE', icon: 'â„ï¸', baseDmg: 20, cost: 12, time: 1.2, desc: 'è¾ƒä½ä¼¤å®³ï¼Œè¾ƒå¿«' },
    'heal': { id: 'heal', name: 'æ²»ç–—æœ¯', type: 'CORE', icon: 'ğŸ’š', baseHeal: 30, cost: 15, time: 2.0, desc: 'æ¢å¤ç”Ÿå‘½å€¼' },
    
    // ä¿®é¥°ç¬¦
    'amp': { id: 'amp', name: 'å¼ºåŒ–', type: 'MOD', icon: 'âš¡', dmgMult: 1.5, costMult: 1.3, timeAdd: 0.5, desc: 'ä¼¤å®³+50%, è€—è“+30%' },
    'quick': { id: 'quick', name: 'è¿…æ·', type: 'MOD', icon: 'ğŸ’¨', dmgMult: 0.8, costMult: 0.8, timeMult: 0.6, desc: 'ä¼¤å®³-20%, æ—¶é—´-40%' },
    'double': { id: 'double', name: 'åŒé‡', type: 'MOD', icon: 'ğŸ”', count: 2, costMult: 1.8, timeMult: 1.6, desc: 'é‡Šæ”¾ä¸¤æ¬¡' }
};

const ENEMIES = {
    'wolf': { name: 'æ¶ç‹¼', hp: 60, maxHp: 60, dmg: 8, speed: 15, icon: 'ğŸº' },
    'goblin': { name: 'å“¥å¸ƒæ—', hp: 40, maxHp: 40, dmg: 6, speed: 20, icon: 'ğŸ‘º' },
    'ogre': { name: 'é£Ÿäººé­”', hp: 120, maxHp: 120, dmg: 15, speed: 8, icon: 'ğŸ‘¹' }
};

/**
 * æ¸¸æˆçŠ¶æ€
 */
const state = {
    scene: 'camp', // 'camp', 'battle'
    player: {
        hp: 100, maxHp: 100,
        mp: 50, maxMp: 50,
        speed: 12,
        spells: [ // é¢„è®¾ä¸‰ä¸ªå¡æ§½
            ['firebolt'], 
            ['amp', 'firebolt'], 
            ['heal']
        ]
    },
    enemy: null,
    battle: {
        active: false,
        lastTime: 0,
        playerAtb: 0,
        enemyAtb: 0,
        playerStatus: 'charging', // charging, ready, casting, stunned
        enemyStatus: 'charging',
        castProgress: 0,
        currentSpellIndex: -1,
        interruptThreshold: 10 // å—åˆ°å¤šå°‘ä¼¤å®³ä¼šæ‰“æ–­æ–½æ³•
    }
};

/**
 * æ ¸å¿ƒé€»è¾‘å¼•æ“
 */
const engine = {
    // è®¡ç®—ä¸€ä¸ªæ³•æœ¯é“¾çš„å±æ€§
    calculateSpell: (chain) => {
        if (!chain || chain.length === 0) return null;

        let totalCost = 0;
        let totalTime = 0;
        let totalDmg = 0;
        let totalHeal = 0;
        let isDamage = false;
        let isHeal = false;
        let nameParts = [];

        // ç®€å•è§£æï¼šä»å·¦åˆ°å³ï¼Œä¿®é¥°ç¬¦ä½œç”¨äºç´§éšå…¶åçš„æ ¸å¿ƒç¬¦
        // ä¸ºäº†åŸå‹ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾ï¼šä¿®é¥°ç¬¦å¿…é¡»æ”¾åœ¨æ ¸å¿ƒç¬¦å‰é¢æ‰æœ‰æ•ˆï¼Œæˆ–è€…æˆ‘ä»¬éå†å¤„ç†
        
        // æ›´ç®€å•çš„é€»è¾‘ï¼šæ‰¾åˆ°æ ¸å¿ƒç¬¦ï¼Œåº”ç”¨å‰é¢çš„ä¿®é¥°ç¬¦
        // è¿™é‡Œé‡‡ç”¨ç´¯åŠ é€»è¾‘ï¼šé‡åˆ°ä¿®é¥°ç¬¦æš‚å­˜ï¼Œé‡åˆ°æ ¸å¿ƒç¬¦ç»“ç®—
        
        let pendingMods = [];

        for (let runeId of chain) {
            const rune = RUNES[runeId];
            if (!rune) continue;

            if (rune.type === 'MOD') {
                pendingMods.push(rune);
            } else if (rune.type === 'CORE') {
                // åº”ç”¨æ‰€æœ‰æš‚å­˜çš„ä¿®é¥°ç¬¦åˆ°è¿™ä¸ªæ ¸å¿ƒç¬¦
                let cDmg = rune.baseDmg || 0;
                let cHeal = rune.baseHeal || 0;
                let cCost = rune.cost;
                let cTime = rune.time;
                let count = 1;

                // åº”ç”¨ä¿®é¥°ç¬¦ (ä»åå¾€å‰åº”ç”¨ï¼Œæˆ–è€…æŒ‰é¡ºåºï¼Œè¿™é‡Œç®€å•å¤„ç†ä¸ºä¹˜æ³•å åŠ )
                for (let mod of pendingMods) {
                    if (mod.dmgMult) cDmg *= mod.dmgMult;
                    if (mod.costMult) cCost *= mod.costMult;
                    if (mod.timeMult) cTime *= mod.timeMult;
                    if (mod.timeAdd) cTime += mod.timeAdd;
                    if (mod.count) count = mod.count; // ç®€å•èµ·è§ï¼Œæœ€åä¸€ä¸ªå¤šé‡ç¬¦ç”Ÿæ•ˆ
                }

                // ç´¯åŠ 
                totalCost += cCost * count;
                totalTime += cTime * count;
                if (cDmg > 0) {
                    totalDmg += cDmg * count;
                    isDamage = true;
                }
                if (cHeal > 0) {
                    totalHeal += cHeal * count;
                    isHeal = true;
                }

                nameParts.push(rune.name);
                pendingMods = []; // é‡ç½®
            }
        }

        // æ„å»ºåç§°
        let fullName = chain.map(id => RUNES[id]?.name).join('+');
        if (fullName === '') fullName = 'æ— æ•ˆæ³•æœ¯';

        return {
            name: fullName,
            cost: Math.floor(totalCost),
            time: parseFloat(totalTime.toFixed(1)),
            damage: Math.floor(totalDmg),
            heal: Math.floor(totalHeal),
            type: isHeal ? 'heal' : 'dmg'
        };
    },

    // æˆ˜æ–—å¾ªç¯
    updateBattle: (timestamp) => {
        if (!state.battle.active) return;
        if (state.scene !== 'battle') return;

        const dt = (timestamp - state.battle.lastTime) / 1000; // ç§’
        state.battle.lastTime = timestamp;

        const b = state.battle;
        const p = state.player;
        const e = state.enemy;

        // 1. æ›´æ–°ç©å®¶ ATB
        if (b.playerStatus === 'charging') {
            b.playerAtb += p.speed * dt * 5; // é€Ÿåº¦ç³»æ•°
            if (b.playerAtb >= 100) {
                b.playerAtb = 100;
                b.playerStatus = 'ready';
                ui.log("ç³»ç»Ÿ", "ä½ çš„å›åˆå°±ç»ªï¼");
                ui.updateUnitVisuals();
                ui.enableButtons(true);
            }
        } else if (b.playerStatus === 'casting') {
            // åŸå”±ä¸­ï¼ŒATB æš‚åœå¢é•¿ï¼Œä½†æ—¶é—´åœ¨èµ°
            b.castProgress += (100 / b.currentSpellTime) * dt;
            if (b.castProgress >= 100) {
                engine.executePlayerSpell();
            }
        } else if (b.playerStatus === 'stunned') {
            // ç¡¬ç›´æ—¶é—´æ¨¡æ‹Ÿ
            b.stunTimer -= dt;
            if (b.stunTimer <= 0) {
                b.playerStatus = 'charging';
                b.playerAtb = 0;
                ui.updateUnitVisuals();
            }
        }

        // 2. æ›´æ–°æ•Œäºº ATB
        if (b.enemyStatus === 'charging') {
            b.enemyAtb += e.speed * dt * 5;
            if (b.enemyAtb >= 100) {
                b.enemyAtb = 100;
                b.enemyStatus = 'ready';
                ui.updateUnitVisuals();
                
                // æ•Œäºº AI: å¦‚æœå°±ç»ªï¼Œç¨å¾®å»¶è¿Ÿä¸€ç‚¹ç„¶åæ”»å‡»
                setTimeout(() => {
                    if (state.scene === 'battle' && b.enemyStatus === 'ready') {
                        engine.enemyAttack();
                    }
                }, 500);
            }
        }

        ui.renderBattleFrame();
        requestAnimationFrame(engine.updateBattle);
    },

    executePlayerSpell: () => {
        const b = state.battle;
        const spell = b.currentSpellData;
        
        b.playerStatus = 'charging';
        b.castProgress = 0;
        b.currentSpellIndex = -1;
        b.currentSpellData = null;
        b.currentSpellTime = 0;

        // æ‰£è“
        state.player.mp -= spell.cost;
        ui.updateStats();

        // ç”Ÿæ•ˆ
        if (spell.type === 'dmg') {
            // æš´å‡»é€»è¾‘ç®€å•åŒ–
            const isCrit = Math.random() < 0.1;
            let dmg = spell.damage * (isCrit ? 1.5 : 1);
            state.enemy.hp -= dmg;
            ui.log("ç©å®¶", `æ–½æ”¾ ${spell.name}! é€ æˆ ${dmg} ç‚¹ä¼¤å®³${isCrit?' (æš´å‡»!)':''}`);
            document.getElementById('unit-enemy').classList.add('shake');
            setTimeout(()=>document.getElementById('unit-enemy').classList.remove('shake'), 300);
        } else if (spell.type === 'heal') {
            state.player.hp = Math.min(state.player.maxHp, state.player.hp + spell.heal);
            ui.log("ç©å®¶", `æ–½æ”¾ ${spell.name}! æ¢å¤ ${spell.heal} HP`);
        }

        ui.updateStats();
        ui.checkWinCondition();
        ui.enableButtons(false);
        ui.updateUnitVisuals();
    },

    enemyAttack: () => {
        const b = state.battle;
        const e = state.enemy;
        
        // æ£€æŸ¥æ˜¯å¦æ‰“æ–­ç©å®¶
        if (b.playerStatus === 'casting') {
            // ç®€å•åˆ¤å®šï¼šåªè¦æ”»å‡»å°±æ‰“æ–­ (æˆ–è€…åŠ ä¸ªæ¦‚ç‡)
            ui.log("æ•Œäºº", `${e.name} æ”»å‡»äº†ä½ ï¼(æ‰“æ–­æ–½æ³•!)`, 'error');
            b.playerStatus = 'stunned';
            b.stunTimer = 1.5; // ç¡¬ç›´ 1.5 ç§’
            b.castProgress = 0;
            // æƒ©ç½šï¼šæ‰£é™¤ä¸€åŠå½“å‰æ³•æœ¯è“è€— (å·²æ‰£äº†ï¼Œè¿™é‡Œå†æ‰£ç‚¹æˆ–è€…å•çº¯æµªè´¹)
            state.player.mp = Math.max(0, state.player.mp - Math.floor(b.currentSpellData.cost / 2));
            ui.updateStats();
            document.getElementById('unit-player').classList.add('shake');
            setTimeout(()=>document.getElementById('unit-player').classList.remove('shake'), 300);
        } else {
            // æ­£å¸¸ä¼¤å®³
            const dmg = e.dmg + Math.floor(Math.random() * 3);
            state.player.hp -= dmg;
            ui.log("æ•Œäºº", `${e.name} æ”»å‡»äº†ä½ ï¼é€ æˆ ${dmg} ä¼¤å®³`, 'enemy');
            document.getElementById('unit-player').classList.add('shake');
            setTimeout(()=>document.getElementById('unit-player').classList.remove('shake'), 300);
            ui.updateStats();
            if (state.player.hp <= 0) {
                game.gameOver();
                return;
            }
        }

        b.enemyStatus = 'charging';
        b.enemyAtb = 0;
        ui.updateUnitVisuals();
    },

    startBattle: (enemyKey) => {
        state.scene = 'battle';
        state.enemy = JSON.parse(JSON.stringify(ENEMIES[enemyKey])); // å…‹éš†
        state.battle = {
            active: true,
            lastTime: performance.now(),
            playerAtb: 0,
            enemyAtb: 0,
            playerStatus: 'charging',
            enemyStatus: 'charging',
            castProgress: 0,
            currentSpellIndex: -1,
            currentSpellData: null,
            currentSpellTime: 0,
            stunTimer: 0
        };
        
        state.player.mp = Math.min(state.player.maxMp, state.player.mp + 20); // æˆ˜æ–—å›ç‚¹è“

        ui.switchScene('battle');
        ui.initBattleUI();
        ui.log("ç³»ç»Ÿ", `é­é‡äº† ${state.enemy.name}!`, 'system');
        
        requestAnimationFrame(engine.updateBattle);
    }
};

/**
 * UI ç®¡ç†
 */
const ui = {
    log: (source, msg, type='normal') => {
        const logEl = document.getElementById('combat-log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.innerText = `[${source}] ${msg}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
    },

    updateStats: () => {
        const p = state.player;
        document.getElementById('player-hp-text').innerText = `${p.hp}/${p.maxHp}`;
        document.getElementById('player-hp-bar').style.width = `${(p.hp/p.maxHp)*100}%`;
        document.getElementById('player-mp-text').innerText = `${p.mp}/${p.maxMp}`;
        document.getElementById('player-mp-bar').style.width = `${(p.mp/p.maxMp)*100}%`;
    },

    switchScene: (sceneName) => {
        document.getElementById('battle-field').style.display = sceneName === 'battle' ? 'flex' : 'none';
        document.getElementById('camp-scene').style.display = sceneName === 'camp' ? 'block' : 'none';
        document.getElementById('camp-editor').style.display = sceneName === 'camp' ? 'block' : 'none';
        document.getElementById('battle-controls').style.display = sceneName === 'battle' ? 'block' : 'none';
        document.getElementById('scene-title').innerText = sceneName === 'camp' ? 'å®‰å…¨è¥åœ°' : 'æˆ˜æ–—ä¸­';
        
        if (sceneName === 'camp') {
            this.renderCampEditor();
        }
    },

    renderCampEditor: () => {
        const container = document.getElementById('spell-slots-container');
        container.innerHTML = '';
        
        state.player.spells.forEach((chain, index) => {
            const slot = document.createElement('div');
            const stats = engine.calculateSpell(chain);
            slot.className = `slot ${chain.length > 0 ? 'filled' : ''}`;
            slot.onclick = () => {
                // ç‚¹å‡»æ¸…ç©ºè¯¥æ§½ä½
                if(confirm('æ¸…ç©ºè¿™ä¸ªæ³•æœ¯æ§½ï¼Ÿ')) {
                    state.player.spells[index] = [];
                    this.renderCampEditor();
                }
            };

            let content = '';
            if (chain.length === 0) {
                content = `<span style="color:#666">ç©ºæ§½ä½</span>`;
            } else {
                content = `
                    <div class="slot-info">
                        <div style="font-weight:bold; color:#fff">${stats.name}</div>
                        <div style="color:#f1c40f">â±ï¸ ${stats.time}s</div>
                        <div style="color:#3498db">ğŸ’§ ${stats.cost} MP</div>
                        <div style="color:#e74c3c">âš”ï¸ ${stats.damage || stats.heal}</div>
                    </div>
                    <div class="slot-remove">Ã—</div>
                `;
            }
            slot.innerHTML = content;
            container.appendChild(slot);
        });

        // æ¸²æŸ“åº“
        const lib = document.getElementById('rune-library');
        lib.innerHTML = '';
        Object.values(RUNES).forEach(rune => {
            const item = document.createElement('div');
            item.className = 'rune-item';
            item.innerHTML = `
                <div class="rune-icon">${rune.icon}</div>
                <div>${rune.name}</div>
                <div class="rune-type">${rune.type}</div>
            `;
            item.onclick = () => this.addRuneToFirstEmptySlot(rune.id);
            lib.appendChild(item);
        });
    },

    addRuneToFirstEmptySlot: (runeId) => {
        // ç®€å•é€»è¾‘ï¼šæ·»åŠ åˆ°ç¬¬ä¸€ä¸ªéæ»¡çš„æ§½ä½ï¼Œæˆ–è€…è¿½åŠ åˆ°æœ€åä¸€ä¸ªé€‰ä¸­çš„æ§½ä½ï¼Ÿ
        // åŸå‹ç®€åŒ–ï¼šæ€»æ˜¯æ·»åŠ åˆ°ç¬¬ä¸€ä¸ªæ§½ä½ä½œä¸ºæ¼”ç¤ºï¼Œæˆ–è€…è®©ç”¨æˆ·æ‰‹åŠ¨æ”¹ï¼Ÿ
        // æ”¹è¿›ï¼šæ·»åŠ åˆ°ç¬¬ä¸€ä¸ªæ§½ä½ï¼Œå¦‚æœæ»¡äº†æç¤º
        if (state.player.spells.length >= 4) {
            alert("ç¬¬ä¸€ä¸ªæ§½ä½å·²æ»¡ï¼(åŸå‹é™åˆ¶)");
            return;
        }
        state.player.spells.push(runeId);
        this.renderCampEditor();
    },

    initBattleUI: () => {
        document.getElementById('enemy-name').innerText = state.enemy.name;
        document.getElementById('unit-enemy').querySelector('.unit-avatar').innerText = state.enemy.icon;
        this.updateEnemyHp();
        this.renderBattleButtons();
        this.updateUnitVisuals();
    },

    updateEnemyHp: () => {
        const pct = (state.enemy.hp / state.enemy.maxHp) * 100;
        document.getElementById('enemy-hp-text').innerText = `HP: ${Math.max(0, state.enemy.hp)}/${state.enemy.maxHp}`;
        // ç®€å•å˜è‰²
        const avatar = document.getElementById('unit-enemy').querySelector('.unit-avatar');
        if (pct < 30) avatar.style.borderColor = 'red';
        else avatar.style.borderColor = '#666';
    },

    renderBattleButtons: () => {
        const container = document.getElementById('action-buttons');
        container.innerHTML = '';
        
        state.player.spells.forEach((chain, index) => {
            const stats = engine.calculateSpell(chain);
            if (!stats) return;

            const btn = document.createElement('button');
            btn.className = 'spell-btn';
            btn.disabled = true; // é»˜è®¤ç¦ç”¨ï¼ŒATB æ»¡äº†æ‰å¯ç”¨
            btn.id = `spell-btn-${index}`;
            btn.innerHTML = `
                <div style="font-size:20px">${chain.map(id=>RUNES[id].icon).join('')}</div>
                <div style="font-weight:bold; margin:5px 0">${stats.name}</div>
                <div class="time">â±ï¸ ${stats.time}s</div>
                <div class="cost">ğŸ’§ ${stats.cost}</div>
            `;
            btn.onclick = () => game.castSpell(index);
            container.appendChild(btn);
        });
    },

    enableButtons: (enabled) => {
        const btns = document.querySelectorAll('.spell-btn');
        btns.forEach((btn, idx) => {
            const chain = state.player.spells[idx];
            const stats = engine.calculateSpell(chain);
            // é¢å¤–æ£€æŸ¥è“é‡
            if (enabled && state.player.mp >= stats.cost) {
                btn.disabled = false;
                btn.style.opacity = 1;
            } else {
                btn.disabled = true;
                btn.style.opacity = 0.5;
            }
        });
    },

    updateUnitVisuals: () => {
        const pUnit = document.getElementById('unit-player');
        const eUnit = document.getElementById('unit-enemy');
        
        pUnit.classList.remove('ready', 'casting', 'stunned');
        eUnit.classList.remove('ready', 'casting', 'stunned');

        if (state.battle.playerStatus === 'ready') pUnit.classList.add('ready');
        if (state.battle.playerStatus === 'casting') pUnit.classList.add('casting');
        if (state.battle.playerStatus === 'stunned') pUnit.classList.add('stunned');

        if (state.battle.enemyStatus === 'ready') eUnit.classList.add('ready');
    },

    renderBattleFrame: () => {
        document.getElementById('player-atb').style.width = `${state.battle.playerAtb}%`;
        document.getElementById('enemy-atb').style.width = `${state.battle.enemyAtb}%`;
        
        if (state.battle.playerStatus === 'casting') {
            document.getElementById('player-cast').style.width = `${state.battle.castProgress}%`;
        } else {
            document.getElementById('player-cast').style.width = '0%';
        }
        
        this.updateEnemyHp();
    },

    checkWinCondition: () => {
        if (state.enemy.hp <= 0) {
            state.battle.active = false;
            game.victory();
        }
    }
};

/**
 * æ¸¸æˆæ§åˆ¶å™¨
 */
const game = {
    leaveCamp: () => {
        // éšæœºé‡æ•Œ
        const keys = Object.keys(ENEMIES);
        const randomEnemy = keys[Math.floor(Math.random() * keys.length)];
        engine.startBattle(randomEnemy);
    },

    castSpell: (index) => {
        const chain = state.player.spells[index];
        const stats = engine.calculateSpell(chain);
        
        if (state.player.mp < stats.cost) {
            ui.log("ç³»ç»Ÿ", "æ³•åŠ›ä¸è¶³!", "error");
            return;
        }

        const b = state.battle;
        b.playerStatus = 'casting';
        b.currentSpellIndex = index;
        b.currentSpellData = stats;
        b.currentSpellTime = stats.time;
        b.castProgress = 0;
        
        ui.log("ç©å®¶", `å¼€å§‹åŸå”±ï¼š${stats.name}... (${stats.time}s)`);
        ui.enableButtons(false);
        ui.updateUnitVisuals();
    },

    victory: () => {
        document.getElementById('overlay-title').innerText = "æˆ˜æ–—èƒœåˆ©!";
        document.getElementById('overlay-msg').innerText = `å‡»è´¥äº† ${state.enemy.name}ï¼Œæ¢å¤äº†éƒ¨åˆ†æ³•åŠ›ã€‚`;
        document.getElementById('overlay').classList.add('active');
        this.nextAction = 'camp';
    },

    gameOver: () => {
        document.getElementById('overlay-title').innerText = "ä½ å¤±è´¥äº†...";
        document.getElementById('overlay-msg').innerText = "è¢«å‡»å€’åœ¨è’é‡ä¸­ã€‚";
        document.getElementById('overlay').classList.add('active');
        this.nextAction = 'restart';
    },

    handleOverlayAction: () => {
        document.getElementById('overlay').classList.remove('active');
        if (this.nextAction === 'camp') {
            // å›è¥å›è¡€
            state.player.hp = state.player.maxHp;
            state.player.mp = state.player.maxMp;
            ui.updateStats();
            ui.switchScene('camp');
            ui.log("ç³»ç»Ÿ", "å›åˆ°äº†è¥åœ°ï¼ŒçŠ¶æ€å·²æ¢å¤ã€‚");
        } else if (this.nextAction === 'restart') {
            location.reload();
        }
    }
};

// åˆå§‹åŒ–
window.onload = () => {
    ui.switchScene('camp');
    ui.updateStats();
    ui.log("ç³»ç»Ÿ", "æ¬¢è¿æ¥åˆ°é­”æ³•ç¼–ç¨‹åŸå‹ã€‚åœ¨è¥åœ°é…ç½®æ³•æœ¯ï¼Œç„¶åå‡ºå‘æˆ˜æ–—ï¼");
};

</script>
</body>
</html>
